---
layout: security_patch
cve: CVE-2010-0402
first_version: 1.0.0
last_version: 1.0.0
---

Index: src/terraform_cmd.cpp
===================================================================
--- src/terraform_cmd.cpp	(revision 19678)
+++ src/terraform_cmd.cpp	(working copy)
@@ -372,7 +372,7 @@
 	uint oldh = TileHeight(p1);

 	/* compute new height */
-	uint h = oldh + p2;
+	uint h = oldh + (int8)p2;

 	/* Check range of destination height */
 	if (h > MAX_TILE_HEIGHT) return_cmd_error((oldh == 0) ? STR_ERROR_ALREADY_AT_SEA_LEVEL : STR_ERROR_TOO_HIGH);
Index: src/rail_cmd.cpp
===================================================================
--- src/rail_cmd.cpp	(revision 19678)
+++ src/rail_cmd.cpp	(working copy)
@@ -369,8 +369,8 @@
  */
 CommandCost CmdBuildSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	RailType railtype = (RailType)p1;
-	Track track = (Track)p2;
+	RailType railtype = (RailType)GB(p1, 0, 4);
+	Track track = (Track)GB(p2, 0, 3);
 	CommandCost cost(EXPENSES_CONSTRUCTION);

 	if (!ValParamRailtype(railtype) || !ValParamTrackOrientation(track)) return CMD_ERROR;
@@ -509,11 +509,11 @@
  */
 CommandCost CmdRemoveSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	Track track = (Track)p2;
+	Track track = (Track)GB(p2, 0, 3);
 	CommandCost cost(EXPENSES_CONSTRUCTION);
 	bool crossing = false;

-	if (!ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
+	if (!ValParamTrackOrientation(track)) return CMD_ERROR;
 	TrackBits trackbit = TrackToTrackBits(track);

 	/* Need to read tile owner now because it may change when the rail is removed
@@ -830,6 +830,7 @@
 CommandCost CmdBuildTrainDepot(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	/* check railtype and valid direction for depot (0 through 3), 4 in total */
+	p1 = GB(p1, 0, 4);
 	if (!ValParamRailtype((RailType)p1)) return CMD_ERROR;

 	Slope tileh = GetTileSlope(tile, NULL);
@@ -905,6 +906,7 @@
 	uint num_dir_cycle = GB(p1, 15, 2);

 	if (sigtype > SIGTYPE_LAST) return CMD_ERROR;
+	if (cycle_start > cycle_stop || cycle_stop > SIGTYPE_LAST) return CMD_ERROR;

 	/* You can only build signals on plain rail tiles, and the selected track must exist */
 	if (!ValParamTrackOrientation(track) || !IsPlainRailTile(tile) ||
@@ -1127,10 +1129,9 @@
 	bool semaphores = HasBit(p2, 4);
 	bool remove = HasBit(p2, 5);
 	bool autofill = HasBit(p2, 6);
-	Trackdir trackdir = TrackToTrackdir(track);
 	byte signal_density = GB(p2, 24, 8);

-	if (p1 >= MapSize()) return CMD_ERROR;
+	if (p1 >= MapSize() || !ValParamTrackOrientation(track)) return CMD_ERROR;
 	TileIndex end_tile = p1;
 	if (signal_density == 0 || signal_density > 20) return CMD_ERROR;

@@ -1140,6 +1141,7 @@
 	 * since the original amount will be too dense (shorter tracks) */
 	signal_density *= 2;

+	Trackdir trackdir = TrackToTrackdir(track);
 	if (ValidateAutoDrag(&trackdir, tile, end_tile).Failed()) return CMD_ERROR;

 	track = TrackdirToTrack(trackdir); // trackdir might have changed, keep track in sync
@@ -1361,7 +1363,7 @@
 CommandCost CmdConvertRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	CommandCost cost(EXPENSES_CONSTRUCTION);
-	RailType totype = (RailType)p2;
+	RailType totype = (RailType)GB(p2, 0, 4);

 	if (!ValParamRailtype(totype)) return CMD_ERROR;
 	if (p1 >= MapSize()) return CMD_ERROR;
Index: src/group_cmd.cpp
===================================================================
--- src/group_cmd.cpp	(revision 19678)
+++ src/group_cmd.cpp	(working copy)
@@ -82,7 +82,7 @@
  */
 CommandCost CmdCreateGroup(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	VehicleType vt = (VehicleType)p1;
+	VehicleType vt = (VehicleType)GB(p1, 0, 3);
 	if (!IsCompanyBuildableVehicleType(vt)) return CMD_ERROR;

 	if (!Group::CanAllocateItem()) return CMD_ERROR;
@@ -258,13 +258,12 @@
  */
 CommandCost CmdAddSharedVehicleGroup(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	VehicleType type = (VehicleType)p2;
-	if (!Group::IsValidID(p1) || !IsCompanyBuildableVehicleType(type)) return CMD_ERROR;
+	VehicleType type = (VehicleType)GB(p2, 0, 3);
+	GroupID id_g = p1;
+	if (!Group::IsValidID(id_g) || !IsCompanyBuildableVehicleType(type)) return CMD_ERROR;

 	if (flags & DC_EXEC) {
 		Vehicle *v;
-		VehicleType type = (VehicleType)p2;
-		GroupID id_g = p1;

 		/* Find the first front engine which belong to the group id_g
 		 * then add all shared vehicles of this front engine to the group id_g */
@@ -298,13 +297,13 @@
  */
 CommandCost CmdRemoveAllVehiclesGroup(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	Group *g = Group::GetIfValid(p1);
-	VehicleType type = (VehicleType)p2;
+	GroupID old_g = p1;
+	Group *g = Group::GetIfValid(old_g);
+	VehicleType type = (VehicleType)GB(p2, 0, 3);

 	if (g == NULL || g->owner != _current_company || !IsCompanyBuildableVehicleType(type)) return CMD_ERROR;

 	if (flags & DC_EXEC) {
-		GroupID old_g = p1;
 		Vehicle *v;

 		/* Find each Vehicle that belongs to the group old_g and add it to the default group */
Index: src/vehiclelist.h
===================================================================
--- src/vehiclelist.h	(revision 19678)
+++ src/vehiclelist.h	(working copy)
@@ -19,7 +19,7 @@

 typedef SmallVector<const Vehicle *, 32> VehicleList;

-void GenerateVehicleSortList(VehicleList *list, VehicleType type, Owner owner, uint32 index, uint16 window_type);
+bool GenerateVehicleSortList(VehicleList *list, VehicleType type, Owner owner, uint32 index, uint16 window_type);
 void BuildDepotVehicleList(VehicleType type, TileIndex tile, VehicleList *engine_list, VehicleList *wagon_list, bool individual_wagons = false);

 #endif /* VEHICLELIST_H */
Index: src/station_cmd.cpp
===================================================================
--- src/station_cmd.cpp	(revision 19678)
+++ src/station_cmd.cpp	(working copy)
@@ -1521,6 +1521,7 @@
  */
 CommandCost CmdBuildRoadStop(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 2);
 	bool type = HasBit(p2, 0);
 	bool is_drive_through = HasBit(p2, 1);
 	bool build_over_road  = is_drive_through && IsNormalRoadTile(tile);
Index: src/vehiclelist.cpp
===================================================================
--- src/vehiclelist.cpp	(revision 19678)
+++ src/vehiclelist.cpp	(working copy)
@@ -76,8 +76,9 @@
  *      <li>VLW_WAYPOINT_LIST: index of waypoint to generate a list for</li>
  *    </ul>
  * @param window_type The type of window the list is for, using the VLW_ flags in vehicle_gui.h
+ * @return false if invalid list is requested
  */
-void GenerateVehicleSortList(VehicleList *list, VehicleType type, Owner owner, uint32 index, uint16 window_type)
+bool GenerateVehicleSortList(VehicleList *list, VehicleType type, Owner owner, uint32 index, uint16 window_type)
 {
 	list->Clear();

@@ -101,7 +102,10 @@

 		case VLW_SHARED_ORDERS:
 			/* Add all vehicles from this vehicle's shared order list */
-			for (v = Vehicle::Get(index); v != NULL; v = v->NextShared()) {
+			v = Vehicle::GetIfValid(index);
+			if (v == NULL || v->type != type || !v->IsPrimaryVehicle()) return false;
+
+			for (; v != NULL; v = v->NextShared()) {
 				*list->Append() = v;
 			}
 			break;
@@ -153,8 +157,9 @@
 			}
 			break;

-		default: NOT_REACHED();
+		default: return false;
 	}

 	list->Compact();
+	return true;
 }
Index: src/ship_cmd.cpp
===================================================================
--- src/ship_cmd.cpp	(revision 19678)
+++ src/ship_cmd.cpp	(working copy)
@@ -611,6 +611,7 @@
  */
 CommandCost CmdBuildShip(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 16);
 	UnitID unit_num;

 	if (!IsEngineBuildable(p1, VEH_SHIP, _current_company)) return_cmd_error(STR_ERROR_SHIP_NOT_AVAILABLE);
Index: src/order_cmd.cpp
===================================================================
--- src/order_cmd.cpp	(revision 19678)
+++ src/order_cmd.cpp	(working copy)
@@ -468,7 +468,7 @@
 	Order new_order(p2);

 	Vehicle *v = Vehicle::GetIfValid(veh);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	/* Check if the inserted order is to the correct destination (owner, type),
 	 * and has the correct flags if any */
@@ -547,8 +547,6 @@
 						default: return CMD_ERROR;
 					}
 				}
-			} else {
-				if (!IsCompanyBuildableVehicleType(v)) return CMD_ERROR;
 			}

 			if (new_order.GetNonStopType() != ONSF_STOP_EVERYWHERE && v->type != VEH_TRAIN && v->type != VEH_ROAD) return CMD_ERROR;
@@ -729,7 +727,7 @@

 	Vehicle *v = Vehicle::GetIfValid(veh_id);

-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	/* If we did not select an order, we maybe want to de-clone the orders */
 	if (sel_ord >= v->GetNumOrders())
@@ -795,10 +793,7 @@

 	Vehicle *v = Vehicle::GetIfValid(veh_id);

-	if (v == NULL || !CheckOwnership(v->owner) || sel_ord == v->cur_order_index ||
-			sel_ord >= v->GetNumOrders() || v->GetNumOrders() < 2) {
-		return CMD_ERROR;
-	}
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner) || sel_ord == v->cur_order_index || sel_ord >= v->GetNumOrders() || v->GetNumOrders() < 2) return CMD_ERROR;

 	if (flags & DC_EXEC) {
 		v->cur_order_index = sel_ord;
@@ -835,7 +830,7 @@
 	VehicleOrderID target_order = GB(p2, 16, 16);

 	Vehicle *v = Vehicle::GetIfValid(veh);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	/* Don't make senseless movements */
 	if (moving_order >= v->GetNumOrders() || target_order >= v->GetNumOrders() ||
@@ -916,7 +911,7 @@
 	if (mof >= MOF_END) return CMD_ERROR;

 	Vehicle *v = Vehicle::GetIfValid(veh);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	/* Is it a valid order? */
 	if (sel_ord >= v->GetNumOrders()) return CMD_ERROR;
@@ -1139,17 +1134,14 @@
 	VehicleID veh_dst = GB(p1,  0, 16);

 	Vehicle *dst = Vehicle::GetIfValid(veh_dst);
+	if (dst == NULL || !dst->IsPrimaryVehicle() || !CheckOwnership(dst->owner)) return CMD_ERROR;

-	if (dst == NULL || !CheckOwnership(dst->owner)) return CMD_ERROR;
-
 	switch (p2) {
 		case CO_SHARE: {
 			Vehicle *src = Vehicle::GetIfValid(veh_src);

 			/* Sanity checks */
-			if (src == NULL || !CheckOwnership(src->owner) || dst->type != src->type || dst == src) {
-				return CMD_ERROR;
-			}
+			if (src == NULL || !src->IsPrimaryVehicle() || !CheckOwnership(src->owner) || dst->type != src->type || dst == src) return CMD_ERROR;

 			/* Trucks can't share orders with busses (and visa versa) */
 			if (src->type == VEH_ROAD && RoadVehicle::From(src)->IsBus() != RoadVehicle::From(dst)->IsBus()) {
@@ -1188,9 +1180,7 @@
 			Vehicle *src = Vehicle::GetIfValid(veh_src);

 			/* Sanity checks */
-			if (src == NULL || !CheckOwnership(src->owner) || dst->type != src->type || dst == src) {
-				return CMD_ERROR;
-			}
+			if (src == NULL || !src->IsPrimaryVehicle() || !CheckOwnership(src->owner) || dst->type != src->type || dst == src) return CMD_ERROR;

 			/* Trucks can't copy all the orders from busses (and visa versa),
 			 * and neither can helicopters and aircarft. */
@@ -1263,8 +1253,10 @@
 	CargoID cargo = GB(p2, 0, 8);
 	byte subtype  = GB(p2, 8, 8);

+	if (cargo >= NUM_CARGO) return CMD_ERROR;
+
 	const Vehicle *v = Vehicle::GetIfValid(veh);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	Order *order = v->GetOrder(order_number);
 	if (order == NULL) return CMD_ERROR;
@@ -1416,7 +1408,8 @@

 	Vehicle *v = Vehicle::GetIfValid(p1);
 	/* Check the vehicle type and ownership, and if the service interval and order are in range */
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;
+
 	if (serv_int != GetServiceIntervalClamped(serv_int, v->owner) || cur_ord >= v->GetNumOrders()) return CMD_ERROR;

 	if (flags & DC_EXEC) {
Index: src/vehicle_cmd.cpp
===================================================================
--- src/vehicle_cmd.cpp	(revision 19678)
+++ src/vehicle_cmd.cpp	(working copy)
@@ -13,6 +13,7 @@
 #include "roadveh.h"
 #include "news_func.h"
 #include "airport.h"
+#include "cmd_helper.h"
 #include "command_func.h"
 #include "company_func.h"
 #include "vehicle_gui.h"
@@ -130,15 +131,17 @@
 CommandCost CmdMassStartStopVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	VehicleList list;
-	VehicleType vehicle_type = (VehicleType)GB(p2, 0, 5);
+	VehicleType vehicle_type = (VehicleType)GB(p2, 0, 3);
 	bool start_stop = HasBit(p2, 5);
 	bool vehicle_list_window = HasBit(p2, 6);

+	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
+
 	if (vehicle_list_window) {
 		uint32 id = p1;
 		uint16 window_type = p2 & VLW_MASK;

-		GenerateVehicleSortList(&list, vehicle_type, _current_company, id, window_type);
+		if (!GenerateVehicleSortList(&list, vehicle_type, _current_company, id, window_type)) return CMD_ERROR;
 	} else {
 		/* Get the list of vehicles in the depot */
 		BuildDepotVehicleList(vehicle_type, tile, &list, NULL);
@@ -177,9 +180,11 @@
 	VehicleList list;

 	CommandCost cost(EXPENSES_NEW_VEHICLES);
-	VehicleType vehicle_type = (VehicleType)GB(p1, 0, 8);
+	VehicleType vehicle_type = (VehicleType)GB(p1, 0, 3);
 	uint sell_command = GetCmdSellVeh(vehicle_type);

+	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
+
 	/* Get the list of vehicles in the depot */
 	BuildDepotVehicleList(vehicle_type, tile, &list, &list);

@@ -205,8 +210,9 @@
 {
 	VehicleList list;
 	CommandCost cost = CommandCost(EXPENSES_NEW_VEHICLES);
-	VehicleType vehicle_type = (VehicleType)GB(p1, 0, 8);
+	VehicleType vehicle_type = (VehicleType)GB(p1, 0, 3);

+	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
 	if (!IsDepotTile(tile) || !IsTileOwner(tile, _current_company)) return CMD_ERROR;

 	/* Get the list of vehicles in the depot */
@@ -392,7 +398,7 @@
 	uint32 build_argument = 2;

 	Vehicle *v = Vehicle::GetIfValid(p1);
-	if (v == NULL) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
 	Vehicle *v_front = v;
 	Vehicle *w = NULL;
 	Vehicle *w_front = NULL;
@@ -577,7 +583,7 @@
 {
 	VehicleList list;

-	GenerateVehicleSortList(&list, type, owner, id, vlw_flag);
+	if (!GenerateVehicleSortList(&list, type, owner, id, vlw_flag)) return CMD_ERROR;

 	/* Send all the vehicles to a depot */
 	for (uint i = 0; i < list.Length(); i++) {
@@ -607,7 +613,7 @@
 CommandCost CmdRenameVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	Vehicle *v = Vehicle::GetIfValid(p1);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	bool reset = StrEmpty(text);

@@ -638,7 +644,7 @@
 CommandCost CmdChangeServiceInt(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	Vehicle *v = Vehicle::GetIfValid(p1);
-	if (v == NULL || !CheckOwnership(v->owner)) return CMD_ERROR;
+	if (v == NULL || !v->IsPrimaryVehicle() || !CheckOwnership(v->owner)) return CMD_ERROR;

 	uint16 serv_int = GetServiceIntervalClamped(p2, v->owner); // Double check the service interval from the user-input
 	if (serv_int != p2) return CMD_ERROR;
Index: src/train_cmd.cpp
===================================================================
--- src/train_cmd.cpp	(revision 19678)
+++ src/train_cmd.cpp	(working copy)
@@ -816,6 +816,7 @@
  */
 CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 16);
 	/* Check if the engine-type is valid (for the company) */
 	if (!IsEngineBuildable(p1, VEH_TRAIN, _current_company)) return_cmd_error(STR_ERROR_RAIL_VEHICLE_NOT_AVAILABLE);

Index: src/tunnelbridge_cmd.cpp
===================================================================
--- src/tunnelbridge_cmd.cpp	(revision 19678)
+++ src/tunnelbridge_cmd.cpp	(working copy)
@@ -210,7 +210,7 @@
 			break;

 		case TRANSPORT_RAIL:
-			railtype = (RailType)GB(p2, 8, 7);
+			railtype = (RailType)GB(p2, 8, 4);
 			if (!ValParamRailtype(railtype)) return CMD_ERROR;
 			break;

@@ -482,7 +482,7 @@

 	_build_tunnel_endtile = 0;
 	if (transport_type == TRANSPORT_RAIL) {
-		if (!ValParamRailtype((RailType)p1)) return CMD_ERROR;
+		if (!ValParamRailtype((RailType)GB(p1, 0, 4))) return CMD_ERROR;
 	} else {
 		const RoadTypes rts = (RoadTypes)GB(p1, 0, 2);
 		if (!AreValidRoadTypes(rts) || !HasRoadTypesAvail(_current_company, rts)) return CMD_ERROR;
Index: src/water_cmd.cpp
===================================================================
--- src/water_cmd.cpp	(revision 19678)
+++ src/water_cmd.cpp	(working copy)
@@ -291,7 +291,7 @@
 {
 	CommandCost cost(EXPENSES_CONSTRUCTION);

-	if (p1 >= MapSize()) return CMD_ERROR;
+	if (p1 >= MapSize() || p2 > 2) return CMD_ERROR;

 	/* Outside of the editor you can only build canals, not oceans */
 	if (p2 != 0 && _game_mode != GM_EDITOR) return CMD_ERROR;
Index: src/economy.cpp
===================================================================
--- src/economy.cpp	(revision 19678)
+++ src/economy.cpp	(working copy)
@@ -1502,7 +1502,7 @@
 CommandCost CmdBuyShareInCompany(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	CommandCost cost(EXPENSES_OTHER);
-
+	p1 = GB(p1, 0, 8);
 	Company *c = Company::GetIfValid(p1);

 	/* Check if buying shares is allowed (protection against modified clients)
@@ -1548,6 +1548,7 @@
  */
 CommandCost CmdSellShareInCompany(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 8);
 	Company *c = Company::GetIfValid(p1);

 	/* Check if selling shares is allowed (protection against modified clients)
@@ -1583,6 +1584,7 @@
  */
 CommandCost CmdBuyCompany(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 8);
 	Company *c = Company::GetIfValid(p1);
 	if (c == NULL) return CMD_ERROR;

Index: src/rail.cpp
===================================================================
--- src/rail.cpp	(revision 19678)
+++ src/rail.cpp	(working copy)
@@ -181,7 +181,7 @@

 bool ValParamRailtype(const RailType rail)
 {
-	return HasRailtypeAvail(_current_company, rail);
+	return rail < RAILTYPE_END && HasRailtypeAvail(_current_company, rail);
 }

 RailType GetBestRailtype(const CompanyID company)
Index: src/roadveh_cmd.cpp
===================================================================
--- src/roadveh_cmd.cpp	(revision 19678)
+++ src/roadveh_cmd.cpp	(working copy)
@@ -200,6 +200,7 @@
  */
 CommandCost CmdBuildRoadVeh(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 16);
 	if (!IsEngineBuildable(p1, VEH_ROAD, _current_company)) return_cmd_error(STR_ERROR_ROAD_VEHICLE_NOT_AVAILABLE);

 	const Engine *e = Engine::Get(p1);
Index: src/aircraft_cmd.cpp
===================================================================
--- src/aircraft_cmd.cpp	(revision 19678)
+++ src/aircraft_cmd.cpp	(working copy)
@@ -237,6 +237,7 @@
  */
 CommandCost CmdBuildAircraft(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
+	p1 = GB(p1, 0, 16);
 	if (!IsEngineBuildable(p1, VEH_AIRCRAFT, _current_company)) return_cmd_error(STR_ERROR_AIRCRAFT_NOT_AVAILABLE);

 	const Engine *e = Engine::Get(p1);
