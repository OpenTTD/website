---
layout: security_patch
cve: CVE-2011-3341
first_version: 0.7.0
last_version: 0.7.5
---

Index: src/order_cmd.cpp
===================================================================
--- src/order_cmd.cpp	(revision 22703)
+++ src/order_cmd.cpp	(working copy)
@@ -541,10 +541,10 @@
 		case OT_CONDITIONAL: {
 			VehicleOrderID skip_to = new_order.GetConditionSkipToOrder();
 			if (skip_to != 0 && skip_to >= v->GetNumOrders()) return CMD_ERROR; // Always allow jumping to the first (even when there is no order).
-			if (new_order.GetConditionVariable() > OCV_END) return CMD_ERROR;
+			if (new_order.GetConditionVariable() >= OCV_END) return CMD_ERROR;
 
 			OrderConditionComparator occ = new_order.GetConditionComparator();
-			if (occ > OCC_END) return CMD_ERROR;
+			if (occ >= OCC_END) return CMD_ERROR;
 			switch (new_order.GetConditionVariable()) {
 				case OCV_REQUIRES_SERVICE:
 					if (occ != OCC_IS_TRUE && occ != OCC_IS_FALSE) return CMD_ERROR;
Index: src/company_cmd.cpp
===================================================================
--- src/company_cmd.cpp	(revision 22703)
+++ src/company_cmd.cpp	(working copy)
@@ -636,7 +636,7 @@
 			GroupID id_g = GB(p1, 16, 16);
 			CommandCost cost;
 
-			if (!IsValidGroupID(id_g) && !IsAllGroupID(id_g) && !IsDefaultGroupID(id_g)) return CMD_ERROR;
+			if (IsValidGroupID(id_g) ? GetGroup(id_g)->owner != _current_company : !IsAllGroupID(id_g) && !IsDefaultGroupID(id_g)) return CMD_ERROR;
 			if (new_engine_type != INVALID_ENGINE) {
 				if (!CheckAutoreplaceValidity(old_engine_type, new_engine_type, _current_company)) return CMD_ERROR;
 
Index: src/network/network_command.cpp
===================================================================
--- src/network/network_command.cpp	(revision 22703)
+++ src/network/network_command.cpp	(working copy)
@@ -153,7 +153,7 @@
 	if (!IsValidCommand(cp->cmd))               return "invalid command";
 	if (GetCommandFlags(cp->cmd) & CMD_OFFLINE) return "offline only command";
 	if ((cp->cmd & CMD_FLAGS_MASK) != 0)        return "invalid command flag";
-	if (callback > _callback_table_count)       return "invalid callback";
+	if (callback >= _callback_table_count)      return "invalid callback";
 
 	cp->callback = _callback_table[callback];
 	return NULL;
