---
layout: security_patch
cve: CVE-2011-3342
first_version: 0.6.0
last_version: 0.6.3
---

Index: src/saveload.cpp
===================================================================
--- src/saveload.cpp	(revision 22703)
+++ src/saveload.cpp	(working copy)
@@ -87,6 +87,11 @@
 	throw std::exception();
 }
 
+void SlErrorCorrupt(const char *message)
+{
+	SlError(STR_GAME_SAVELOAD_ERROR_BROKEN_SAVEGAME, message);
+}
+
 /**
  * Fill the input buffer by reading from the file with the given reader
  */
Index: src/misc.cpp
===================================================================
--- src/misc.cpp	(revision 22703)
+++ src/misc.cpp	(working copy)
@@ -189,7 +189,12 @@
 	int index;
 
 	while ((index = SlIterateArray()) != -1) {
+		if (index >= 512) SlErrorCorrupt("Invalid old name index");
+		if (SlGetFieldLength() > 32) SlErrorCorrupt("Invalid old name length");
+
 		SlArray(_name_array[index], SlGetFieldLength(), SLE_UINT8);
+		/* Make sure the name is null terminated */
+		_name_array[index][31] = '\0';
 	}
 }
 
@@ -483,6 +488,8 @@
 	Cheat* cht = (Cheat*)&_cheats;
 	uint count = SlGetFieldLength() / 2;
 	uint i;
+	/* Cannot use lengthof because _cheats is of type Cheats, not Cheat */
+	if (count > sizeof(_cheats) / sizeof(Cheat)) SlErrorCorrupt("Too many cheat values");
 
 	for (i = 0; i < count; i++) {
 		cht[i].been_used = (SlReadByte() != 0);
Index: src/players.cpp
===================================================================
--- src/players.cpp	(revision 22703)
+++ src/players.cpp	(working copy)
@@ -1202,6 +1202,7 @@
 	SlObject(&p->cur_economy, _player_economy_desc);
 
 	/* Write old economy entries. */
+	if (p->num_valid_stat_ent > lengthof(p->old_economy)) SlErrorCorrupt("Too many old economy entries");
 	for (i = 0; i < p->num_valid_stat_ent; i++) {
 		SlObject(&p->old_economy[i], _player_economy_desc);
 	}
Index: src/saveload.h
===================================================================
--- src/saveload.h	(revision 22703)
+++ src/saveload.h	(working copy)
@@ -33,6 +33,7 @@
 SaveOrLoadResult SaveOrLoad(const char *filename, int mode, Subdirectory sb);
 void WaitTillSaved();
 void DoExitSave();
+NORETURN void SlErrorCorrupt(const char *message);
 
 
 typedef void ChunkSaveLoadProc();
